# very-hot

## Overview:

Category: Cryptography

## What We Have:

```src.py```
```c
from Crypto.Util.number import getPrime, isPrime, bytes_to_long
from flag import FLAG

FLAG = bytes_to_long(FLAG.encode())

p = getPrime(384)
while(not isPrime(p + 6) or not isPrime(p + 12)):
    p = getPrime(384)
q = p + 6
r = p + 12

n = p * q * r
e = 2**16 + 1
ct = pow(FLAG, e, n)

print(f'n: {n}')
print(f'e: {e}')
print(f'ct: {ct}')
```

```out.txt```
```c
n: 10565111742779621369865244442986012561396692673454910362609046015925986143478477636135123823568238799221073736640238782018226118947815621060733362956285282617024125831451239252829020159808921127494956720795643829784184023834660903398677823590748068165468077222708643934113813031996923649853965683973247210221430589980477793099978524923475037870799
e: 65537
ct: 9953835612864168958493881125012168733523409382351354854632430461608351532481509658102591265243759698363517384998445400450605072899351246319609602750009384658165461577933077010367041079697256427873608015844538854795998933587082438951814536702595878846142644494615211280580559681850168231137824062612646010487818329823551577905707110039178482377985
```

## Approach

So we have a pretty regular RSA challenge here.

Most important thing to really see here is these equations:

```c
q = p + 6
r = p + 12

n = p * q * r
```

These equations do not allow p, q, and r to be independent.

Meaning there is still a connection between the three of them, as opposed to not being related at all.

Using a tool like z3 can pretty easily solve this system of equations for us.

## Attack

Lets write a python script that will use z3 to solve these system of equations.

```c
from z3 import Solver, Int, sat
from Crypto.Util.number import inverse, long_to_bytes

#Given values
e = 65537
ct = 9953835612864168958493881125012168733523409382351354854632430461608351532481509658102591265243759698363517384998445400450605072899351246319609602750009384658165461577933077010367041079697256427873608015844538854795998933587082438951814536702595878846142644494615211280580559681850168231137824062612646010487818329823551577905707110039178482377985
n = 10565111742779621369865244442986012561396692673454910362609046015925986143478477636135123823568238799221073736640238782018226118947815621060733362956285282617024125831451239252829020159808921127494956720795643829784184023834660903398677823590748068165468077222708643934113813031996923649853965683973247210221430589980477793099978524923475037870799

#prepping z3
x = Int('x')
n_val = Int('n_val')
equation = x * (x + 6) * (x + 12)
solver = Solver()

#inserting our values
solver.add(equation == n_val)
solver.add(n_val == n)

#checking if solvable, if so decrypt
if solver.check() == sat:
    model = solver.model()
    print(f"Solution for x: {model[x]}")
    p = model[x].as_long()
    q = p + 6
    r = p + 12
    phi = (p - 1) * (q - 1) * (r - 1)
    d = inverse(65537, phi)

    pt = pow(ct, d, n)
    print(long_to_bytes(pt).decode())

else:
    print("No solution found.")
```


```text
$ python solve.py
Solution for x: 21942765653871439764422303472543530148312720769660663866142363370143863717044484440248869144329425486818687730842077
lactf{th4t_w45_n0t_so_53xY}
```

## Flag

lactf{th4t_w45_n0t_so_53xY}
